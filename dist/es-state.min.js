const e=(e,r,s)=>{r[e]&&r[e].forEach(e=>e.apply(null,[s]))},r=()=>{return r=>(function r(s,t,o={}){return e(t,o,{...s}),{value:s,observers:o,unobserve(e,r){this.observers[e]=this.observers[e].filter(e=>e!==r)},observe(e,r){return this.observers[e]||(this.observers[e]=[]),this.observers[e].push(r),r({...s}),()=>{this.observers[e]=this.observers[e].filter(e=>e!==r)}},next(e,s){return r(e,s,this.observers)}}})(r)},s=(()=>{const e={};return{on(r,s){e[r]=e[r]?[...e[r],s]:[s]},dispatch(r){e[r.type].forEach(e=>{e(r)})},hasAction:r=>Object.keys(e).find(e=>e.toLowerCase()===r.toLowerCase())}})(),t=({store:e,reducers:t}={})=>(({store:e,reducers:t}={})=>{let o=r()(e);const n={},a=e=>r=>o.observe(e,r),i=(e,r)=>s=>{o=o.next(r(o.value,s),e)};for(const e in t)s.on(e,t[e](e=>{const r=Object.keys(e)[0],s=e[r],t=i(r,s);return n[r]=a(r),t}));return n})({store:e,reducers:t}),o=(()=>new Proxy({},{get:(e,r,t)=>s.hasAction(r)?e=>{if(e instanceof Promise)return async t=>{const o=await e,n=await t(o);s.dispatch({type:r,payload:n})};s.dispatch.apply(null,[{type:r,payload:e}])}:e=>e}))(),n=({type:e,payload:r}=action)=>s.dispatch({type:e,payload:r});export{o as actions,n as dispatch,t as useState};
